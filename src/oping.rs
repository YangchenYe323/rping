use std::ffi::CStr;

use crate::bindings::*;

type Result<'a, T> = core::result::Result<T, PingError<'a>>;

/// Error Type of our Ping structure.
/// The lifetime is tied to the lifetime of the Ping object
/// because the error references a C-String stored in the object. And
/// multiple errors are written to the same buffer address,
/// reference: https://github.com/octo/liboping/blob/master/src/liboping.c
/// Therefore construction of a second [PingError] invalidates the first one becaue
/// the error msg might no longer be valid.
///
/// ## Example
/// ```compile_fail
/// use rping::Ping;
/// use std::ffi::CStr;
/// let mut p = Ping::new();
/// let s1: &'static CStr = unsafe {
///   std::mem::transmute("aaaaunjojlk.com")
/// };
/// let s2: &'static CStr = unsafe {
///   std::mem::transmute("src.com")
/// };
/// let r1 = p.add_host(s1);
/// let r2 = p.add_host(s2); // Error! p is mutably borrowed by r1
///
/// println!("{:?}", r1);
/// ```
///
/// Due to this fact, [PingError] doesn't play well with RUst's ? operator if it is
/// generated by a local [Ping] object, and users are expected to implement their own error
/// handling on top of it.
///
/// ## Example
/// ```compile_fail
/// fn main() -> Result<(), Box<dyn Error>> {
///   use rping::Ping;
///   use std::ffi::CStr;
///   let mut p = Ping::new();
///   let s: &'static CStr = unsafe {
///     std::mem::transmute("github.com");
///   }
///   p.add_host(s)?; // Error! The PingError cannot be propogated outside of the function after p gets dropped.
///   Ok(())
/// }
#[derive(Debug)]
pub struct PingError<'a> {
  // this points inside the Ping object.
  msg: &'a CStr,
}

impl<'a> PingError<'a> {
  fn new(msg: &'a CStr) -> Self {
    Self { msg }
  }
}

impl<'a> core::fmt::Display for PingError<'a> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{:?}", self)
  }
}

// impl<'a> std::error::Error for PingError<'a> {
//   fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
//     None
//   }

//   fn description(&self) -> &str {
//     self.msg.to_str().unwrap()
//   }

//   fn cause(&self) -> Option<&dyn std::error::Error> {
//     self.source()
//   }
// }

/// Safe Rust Wrappers around `pingobj_t` in [liboping](https://noping.cc/)
#[derive(Debug)]
pub struct Ping {
  inner: *mut pingobj_t,
}

impl Ping {
  /// Create a new [Ping].
  pub fn new() -> Self {
    // SAFETY: ping_construct never fails and always
    // returns a valid pointer.
    unsafe {
      Self {
        inner: ping_construct(),
      }
    }
  }

  unsafe fn map_err(&mut self, ret: i32) -> Result<()> {
    match ret {
      0 => Ok(()),
      _ => {
        let ptr = ping_get_error(self.inner);
        let c_str = CStr::from_ptr(ptr);
        Err(PingError::new(c_str))
      }
    }
  }

  /// Add a host to the current ping object so that it can be pinged simultaneously with
  /// all added hosts.
  ///
  pub fn add_host(&mut self, host_name: impl AsRef<CStr>) -> Result<()> {
    unsafe {
      let ret = ping_host_add(self.inner, host_name.as_ref().as_ptr());
      self.map_err(ret)
    }
  }

  /// Remove a host from the lists to be pinged.
  /// Returns error if the host is not resolved or not found.
  ///
  pub fn remove_host(&mut self, host_name: impl AsRef<CStr>) -> Result<()> {
    unsafe {
      let ret = ping_host_remove(self.inner, host_name.as_ref().as_ptr());
      self.map_err(ret)
    }
  }
}

impl Default for Ping {
  fn default() -> Self {
    Self::new()
  }
}

impl Drop for Ping {
  fn drop(&mut self) {
    // SAFETY: self.inner is returned by a valid call of
    // ping_construct, and cannot be modified or invalidated
    // during its lifetime.
    unsafe {
      ping_destroy(self.inner);
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use byte_strings::c;

  #[test]
  fn it_works() {
    let mut p = Ping::new();
    p.add_host(c!("google.com")).unwrap();
  }

  #[test]
  fn err_remove_nonexistent() {
    let mut p = Ping::new();
    let host = c!("google.com");
    assert!(p.remove_host(host).is_err());

    p.add_host(host).unwrap();
    p.remove_host(host).unwrap();
  }
}
