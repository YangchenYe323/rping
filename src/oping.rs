use core::ffi::c_size_t;
use std::{
  ffi::{c_void, CStr},
  marker::PhantomData,
  mem::MaybeUninit,
};

use libc::IP_TOS;

use crate::bindings::*;

type Result<'a, T> = core::result::Result<T, PingError<'a>>;

/// Error Type of our Ping structure.
/// The lifetime is tied to the lifetime of the Ping object
/// because the error references a C-String stored in the object. And
/// multiple errors are written to the same buffer address,
/// reference: https://github.com/octo/liboping/blob/master/src/liboping.c
/// Therefore construction of a second [PingError] invalidates the first one becaue
/// the error msg might no longer be valid.
///
/// ## Example
/// ```compile_fail
/// use rping::Ping;
/// use std::ffi::CStr;
/// let mut p = Ping::new();
/// let s1: &'static CStr = unsafe {
///   std::mem::transmute("aaaaunjojlk.com")
/// };
/// let s2: &'static CStr = unsafe {
///   std::mem::transmute("src.com")
/// };
/// let r1 = p.add_host(s1);
/// let r2 = p.add_host(s2); // Error! p is mutably borrowed by r1
///
/// println!("{:?}", r1);
/// ```
///
/// Due to this fact, [PingError] doesn't play well with RUst's ? operator if it is
/// generated by a local [Ping] object, and users are expected to implement their own error
/// handling on top of it.
///
/// ## Example
/// ```compile_fail
/// fn main() -> Result<(), Box<dyn Error>> {
///   use rping::Ping;
///   use std::ffi::CStr;
///   let mut p = Ping::new();
///   let s: &'static CStr = unsafe {
///     std::mem::transmute("github.com");
///   }
///   p.add_host(s)?; // Error! The PingError cannot be propogated outside of the function after p gets dropped.
///   Ok(())
/// }
#[derive(Debug)]
pub struct PingError<'a> {
  // this points inside the Ping object.
  msg: &'a CStr,
}

impl<'a> PingError<'a> {
  fn new(msg: &'a CStr) -> Self {
    Self { msg }
  }
}

impl<'a> core::fmt::Display for PingError<'a> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{:?}", self)
  }
}

// impl<'a> std::error::Error for PingError<'a> {
//   fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
//     None
//   }

//   fn description(&self) -> &str {
//     self.msg.to_str().unwrap()
//   }

//   fn cause(&self) -> Option<&dyn std::error::Error> {
//     self.source()
//   }
// }

/// Safe Rust Wrappers around `pingobj_t` in [liboping](https://noping.cc/)
#[derive(Debug)]
pub struct Ping {
  inner: *mut pingobj_t,
}

impl Ping {
  /// Create a new [Ping].
  pub fn new() -> Self {
    // SAFETY: ping_construct never fails and always
    // returns a valid pointer.
    unsafe {
      Self {
        inner: ping_construct(),
      }
    }
  }

  unsafe fn map_err(&mut self, ret: i32) -> Result<()> {
    if ret >= 0 {
      Ok(())
    } else {
      let ptr = ping_get_error(self.inner);
      let c_str = CStr::from_ptr(ptr);
      Err(PingError::new(c_str))
    }
  }

  /// Add a host to the current ping object so that it can be pinged simultaneously with
  /// all added hosts.
  ///
  pub fn add_host(&mut self, host_name: impl AsRef<CStr>) -> Result<()> {
    unsafe {
      let ret = ping_host_add(self.inner, host_name.as_ref().as_ptr());
      self.map_err(ret)
    }
  }

  /// Remove a host from the lists to be pinged.
  /// Returns error if the host is not resolved or not found.
  ///
  pub fn remove_host(&mut self, host_name: impl AsRef<CStr>) -> Result<()> {
    unsafe {
      let ret = ping_host_remove(self.inner, host_name.as_ref().as_ptr());
      self.map_err(ret)
    }
  }

  /// Returns a [PingIter] object for iterating over all the associated host
  /// and get information.
  ///
  pub fn iter(&self) -> PingIter<'_> {
    PingIter {
      inner: unsafe { ping_iterator_get(self.inner) },
      _phantom: Default::default(),
    }
  }

  pub fn send(&mut self) -> Result<i32> {
    unsafe {
      let ret = ping_send(self.inner);
      self.map_err(ret)?;
      Ok(ret)
    }
  }
}

impl Default for Ping {
  fn default() -> Self {
    Self::new()
  }
}

impl Drop for Ping {
  fn drop(&mut self) {
    // SAFETY: self.inner is returned by a valid call of
    // ping_construct, and cannot be modified or invalidated
    // during its lifetime.
    unsafe {
      ping_destroy(self.inner);
    }
  }
}

/// Immutable Iterator Type for [Ping],
#[derive(Debug)]
pub struct PingIter<'a> {
  inner: *mut pingobj_iter_t,
  _phantom: PhantomData<&'a ()>,
}

#[derive(Debug)]
pub struct IterInfoHandle<'a> {
  inner: *mut pingobj_iter_t,
  _phantom: PhantomData<&'a ()>,
}

impl<'a> Iterator for PingIter<'a> {
  type Item = IterInfoHandle<'a>;

  fn next(&mut self) -> Option<Self::Item> {
    unsafe {
      let n = ping_iterator_next(self.inner);
      if self.inner.is_null() {
        None
      } else {
        let handle = Some(IterInfoHandle {
          inner: self.inner,
          _phantom: Default::default(),
        });
        self.inner = n;
        handle
      }
    }
  }
}

const INFO_BUFFER_SIZE: usize = 64;

impl<'a> IterInfoHandle<'a> {
  /// Get the user-supplied hostname associated with this host.
  /// This is guaranteed to be equal to user-supplied argument to
  /// `Ping::add_host` without the trailing \0.
  ///
  pub fn get_hostname_user(&self) -> String {
    unsafe {
      // First try a moderate sized buffer.
      let buf = Box::new([0u8; INFO_BUFFER_SIZE]);
      let buf_len: u64 = INFO_BUFFER_SIZE as u64;

      let ret = ping_iterator_get_info(
        self.inner,
        PING_INFO_USERNAME as i32,
        buf.as_ptr() as *const c_void as *mut c_void,
        (&buf_len) as *const u64 as *mut u64,
      );

      // Shouldn't return error
      debug_assert_ne!(libc::EINVAL, ret);

      // If the buffer is not long enough, panic,
      // todo(yangchen): Reallocate a larger buffer?
      if buf_len >= INFO_BUFFER_SIZE as u64 {
        panic!("Buffer Too Short, Needed {} Bytes", buf_len);
      }

      let buf = Box::leak(buf);
      let str = buf.as_ptr() as *const u8 as *mut u8;
      let str_len = buf_len - 1; // Omit the trailing null

      String::from_raw_parts(str, str_len as usize, INFO_BUFFER_SIZE)
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use byte_strings::c;

  #[test]
  fn it_works() {
    let mut p = Ping::new();
    p.add_host(c!("google.com")).unwrap();
  }

  #[test]
  fn err_remove_nonexistent() {
    let mut p = Ping::new();
    let host = c!("google.com");
    assert!(p.remove_host(host).is_err());

    p.add_host(host).unwrap();
    p.remove_host(host).unwrap();
  }

  #[test]
  fn test_send() {
    let mut p = Ping::new();
    let host = c!("google.com");
    p.add_host(host).unwrap();
    assert_eq!(1, p.send().unwrap());

    let mut iter = p.iter();
    println!("{:?}", iter);
    let handle = iter.next().unwrap();
    let c = handle.get_hostname_user();
    assert_eq!("google.com", c);
  }
}
